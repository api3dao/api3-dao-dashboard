/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from '../common';

export interface KlerosLiquidProxyInterface extends utils.Interface {
  functions: {
    'appealCost(uint256)': FunctionFragment;
    'appealKlerosArbitratorRuling(bytes32,address,uint224,string)': FunctionFragment;
    'appealPeriod(uint256)': FunctionFragment;
    'arbitrationCost()': FunctionFragment;
    'claimHashToDisputeIdPlusOne(bytes32)': FunctionFragment;
    'claimsManager()': FunctionFragment;
    'courts(uint256)': FunctionFragment;
    'createDispute(bytes32,address,uint224,string)': FunctionFragment;
    'currentRuling(uint256)': FunctionFragment;
    'disputeIdToClaimDetails(uint256)': FunctionFragment;
    'disputeStatus(uint256)': FunctionFragment;
    'disputes(uint256)': FunctionFragment;
    'executeRuling(uint256)': FunctionFragment;
    'getSubcourt(uint96)': FunctionFragment;
    'klerosArbitrator()': FunctionFragment;
    'klerosArbitratorExtraData()': FunctionFragment;
    'multicall(bytes[])': FunctionFragment;
    'rule(uint256,uint256)': FunctionFragment;
    'submitEvidenceToKlerosArbitrator(uint256,string)': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'appealCost'
      | 'appealKlerosArbitratorRuling'
      | 'appealPeriod'
      | 'arbitrationCost'
      | 'claimHashToDisputeIdPlusOne'
      | 'claimsManager'
      | 'courts'
      | 'createDispute'
      | 'currentRuling'
      | 'disputeIdToClaimDetails'
      | 'disputeStatus'
      | 'disputes'
      | 'executeRuling'
      | 'getSubcourt'
      | 'klerosArbitrator'
      | 'klerosArbitratorExtraData'
      | 'multicall'
      | 'rule'
      | 'submitEvidenceToKlerosArbitrator'
  ): FunctionFragment;

  encodeFunctionData(functionFragment: 'appealCost', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'appealKlerosArbitratorRuling',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'appealPeriod', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'arbitrationCost', values?: undefined): string;
  encodeFunctionData(functionFragment: 'claimHashToDisputeIdPlusOne', values: [PromiseOrValue<BytesLike>]): string;
  encodeFunctionData(functionFragment: 'claimsManager', values?: undefined): string;
  encodeFunctionData(functionFragment: 'courts', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(
    functionFragment: 'createDispute',
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>, PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: 'currentRuling', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'disputeIdToClaimDetails', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'disputeStatus', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'disputes', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'executeRuling', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'getSubcourt', values: [PromiseOrValue<BigNumberish>]): string;
  encodeFunctionData(functionFragment: 'klerosArbitrator', values?: undefined): string;
  encodeFunctionData(functionFragment: 'klerosArbitratorExtraData', values?: undefined): string;
  encodeFunctionData(functionFragment: 'multicall', values: [PromiseOrValue<BytesLike>[]]): string;
  encodeFunctionData(
    functionFragment: 'rule',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: 'submitEvidenceToKlerosArbitrator',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(functionFragment: 'appealCost', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'appealKlerosArbitratorRuling', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'appealPeriod', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'arbitrationCost', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimHashToDisputeIdPlusOne', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'claimsManager', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'courts', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createDispute', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentRuling', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disputeIdToClaimDetails', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disputeStatus', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disputes', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'executeRuling', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getSubcourt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'klerosArbitrator', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'klerosArbitratorExtraData', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rule', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'submitEvidenceToKlerosArbitrator', data: BytesLike): Result;

  events: {
    'AppealedKlerosArbitratorRuling(address,uint256,bytes32)': EventFragment;
    'CreatedDispute(address,uint256,bytes32)': EventFragment;
    'Dispute(address,uint256,uint256,uint256)': EventFragment;
    'Evidence(address,uint256,address,string)': EventFragment;
    'MetaEvidence(uint256,string)': EventFragment;
    'Ruling(address,uint256,uint256)': EventFragment;
    'SubmittedEvidenceToKlerosArbitrator(address,uint256,string)': EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: 'AppealedKlerosArbitratorRuling'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'CreatedDispute'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Dispute'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Evidence'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'MetaEvidence'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'Ruling'): EventFragment;
  getEvent(nameOrSignatureOrTopic: 'SubmittedEvidenceToKlerosArbitrator'): EventFragment;
}

export interface AppealedKlerosArbitratorRulingEventObject {
  sender: string;
  disputeId: BigNumber;
  claimHash: string;
}
export type AppealedKlerosArbitratorRulingEvent = TypedEvent<
  [string, BigNumber, string],
  AppealedKlerosArbitratorRulingEventObject
>;

export type AppealedKlerosArbitratorRulingEventFilter = TypedEventFilter<AppealedKlerosArbitratorRulingEvent>;

export interface CreatedDisputeEventObject {
  claimant: string;
  disputeId: BigNumber;
  claimHash: string;
}
export type CreatedDisputeEvent = TypedEvent<[string, BigNumber, string], CreatedDisputeEventObject>;

export type CreatedDisputeEventFilter = TypedEventFilter<CreatedDisputeEvent>;

export interface DisputeEventObject {
  _arbitrator: string;
  _disputeID: BigNumber;
  _metaEvidenceID: BigNumber;
  _evidenceGroupID: BigNumber;
}
export type DisputeEvent = TypedEvent<[string, BigNumber, BigNumber, BigNumber], DisputeEventObject>;

export type DisputeEventFilter = TypedEventFilter<DisputeEvent>;

export interface EvidenceEventObject {
  _arbitrator: string;
  _evidenceGroupID: BigNumber;
  _party: string;
  _evidence: string;
}
export type EvidenceEvent = TypedEvent<[string, BigNumber, string, string], EvidenceEventObject>;

export type EvidenceEventFilter = TypedEventFilter<EvidenceEvent>;

export interface MetaEvidenceEventObject {
  _metaEvidenceID: BigNumber;
  _evidence: string;
}
export type MetaEvidenceEvent = TypedEvent<[BigNumber, string], MetaEvidenceEventObject>;

export type MetaEvidenceEventFilter = TypedEventFilter<MetaEvidenceEvent>;

export interface RulingEventObject {
  _arbitrator: string;
  _disputeID: BigNumber;
  _ruling: BigNumber;
}
export type RulingEvent = TypedEvent<[string, BigNumber, BigNumber], RulingEventObject>;

export type RulingEventFilter = TypedEventFilter<RulingEvent>;

export interface SubmittedEvidenceToKlerosArbitratorEventObject {
  sender: string;
  disputeId: BigNumber;
  evidence: string;
}
export type SubmittedEvidenceToKlerosArbitratorEvent = TypedEvent<
  [string, BigNumber, string],
  SubmittedEvidenceToKlerosArbitratorEventObject
>;

export type SubmittedEvidenceToKlerosArbitratorEventFilter = TypedEventFilter<SubmittedEvidenceToKlerosArbitratorEvent>;

export interface KlerosLiquidProxy extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: KlerosLiquidProxyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    appealCost(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    appealKlerosArbitratorRuling(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    appealPeriod(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

    arbitrationCost(overrides?: CallOverrides): Promise<[BigNumber]>;

    claimHashToDisputeIdPlusOne(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<[BigNumber]>;

    claimsManager(overrides?: CallOverrides): Promise<[string]>;

    courts(
      subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        parent: BigNumber;
        hiddenVotes: boolean;
        minStake: BigNumber;
        alpha: BigNumber;
        feeForJuror: BigNumber;
        jurorsForCourtJump: BigNumber;
      }
    >;

    createDispute(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    currentRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[BigNumber]>;

    disputeIdToClaimDetails(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, string] & {
        policyHash: string;
        claimant: string;
        amountInUsd: BigNumber;
        evidence: string;
      }
    >;

    disputeStatus(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[number]>;

    disputes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, number, BigNumber, BigNumber, BigNumber, boolean] & {
        subcourtID: BigNumber;
        arbitrated: string;
        numberOfChoices: BigNumber;
        period: number;
        lastPeriodChange: BigNumber;
        drawsInRound: BigNumber;
        commitsInRound: BigNumber;
        ruled: boolean;
      }
    >;

    executeRuling(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getSubcourt(
      subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
        children: BigNumber[];
        timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
      }
    >;

    klerosArbitrator(overrides?: CallOverrides): Promise<[string]>;

    klerosArbitratorExtraData(overrides?: CallOverrides): Promise<[string]>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rule(
      disputeId: PromiseOrValue<BigNumberish>,
      ruling: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitEvidenceToKlerosArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  appealCost(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  appealKlerosArbitratorRuling(
    policyHash: PromiseOrValue<BytesLike>,
    claimant: PromiseOrValue<string>,
    claimAmountInUsd: PromiseOrValue<BigNumberish>,
    evidence: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  appealPeriod(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

  arbitrationCost(overrides?: CallOverrides): Promise<BigNumber>;

  claimHashToDisputeIdPlusOne(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

  claimsManager(overrides?: CallOverrides): Promise<string>;

  courts(
    subcourtID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
      parent: BigNumber;
      hiddenVotes: boolean;
      minStake: BigNumber;
      alpha: BigNumber;
      feeForJuror: BigNumber;
      jurorsForCourtJump: BigNumber;
    }
  >;

  createDispute(
    policyHash: PromiseOrValue<BytesLike>,
    claimant: PromiseOrValue<string>,
    claimAmountInUsd: PromiseOrValue<BigNumberish>,
    evidence: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  currentRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

  disputeIdToClaimDetails(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, BigNumber, string] & {
      policyHash: string;
      claimant: string;
      amountInUsd: BigNumber;
      evidence: string;
    }
  >;

  disputeStatus(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

  disputes(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, BigNumber, number, BigNumber, BigNumber, BigNumber, boolean] & {
      subcourtID: BigNumber;
      arbitrated: string;
      numberOfChoices: BigNumber;
      period: number;
      lastPeriodChange: BigNumber;
      drawsInRound: BigNumber;
      commitsInRound: BigNumber;
      ruled: boolean;
    }
  >;

  executeRuling(
    disputeId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getSubcourt(
    subcourtID: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
      children: BigNumber[];
      timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
    }
  >;

  klerosArbitrator(overrides?: CallOverrides): Promise<string>;

  klerosArbitratorExtraData(overrides?: CallOverrides): Promise<string>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rule(
    disputeId: PromiseOrValue<BigNumberish>,
    ruling: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitEvidenceToKlerosArbitrator(
    disputeId: PromiseOrValue<BigNumberish>,
    evidence: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    appealCost(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    appealKlerosArbitratorRuling(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    appealPeriod(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { start: BigNumber; end: BigNumber }>;

    arbitrationCost(overrides?: CallOverrides): Promise<BigNumber>;

    claimHashToDisputeIdPlusOne(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    claimsManager(overrides?: CallOverrides): Promise<string>;

    courts(
      subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, boolean, BigNumber, BigNumber, BigNumber, BigNumber] & {
        parent: BigNumber;
        hiddenVotes: boolean;
        minStake: BigNumber;
        alpha: BigNumber;
        feeForJuror: BigNumber;
        jurorsForCourtJump: BigNumber;
      }
    >;

    createDispute(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    currentRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    disputeIdToClaimDetails(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, string] & {
        policyHash: string;
        claimant: string;
        amountInUsd: BigNumber;
        evidence: string;
      }
    >;

    disputeStatus(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<number>;

    disputes(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, BigNumber, number, BigNumber, BigNumber, BigNumber, boolean] & {
        subcourtID: BigNumber;
        arbitrated: string;
        numberOfChoices: BigNumber;
        period: number;
        lastPeriodChange: BigNumber;
        drawsInRound: BigNumber;
        commitsInRound: BigNumber;
        ruled: boolean;
      }
    >;

    executeRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<void>;

    getSubcourt(
      subcourtID: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], [BigNumber, BigNumber, BigNumber, BigNumber]] & {
        children: BigNumber[];
        timesPerPeriod: [BigNumber, BigNumber, BigNumber, BigNumber];
      }
    >;

    klerosArbitrator(overrides?: CallOverrides): Promise<string>;

    klerosArbitratorExtraData(overrides?: CallOverrides): Promise<string>;

    multicall(data: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<string[]>;

    rule(
      disputeId: PromiseOrValue<BigNumberish>,
      ruling: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitEvidenceToKlerosArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    'AppealedKlerosArbitratorRuling(address,uint256,bytes32)'(
      sender?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      claimHash?: PromiseOrValue<BytesLike> | null
    ): AppealedKlerosArbitratorRulingEventFilter;
    AppealedKlerosArbitratorRuling(
      sender?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      claimHash?: PromiseOrValue<BytesLike> | null
    ): AppealedKlerosArbitratorRulingEventFilter;

    'CreatedDispute(address,uint256,bytes32)'(
      claimant?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      claimHash?: PromiseOrValue<BytesLike> | null
    ): CreatedDisputeEventFilter;
    CreatedDispute(
      claimant?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      claimHash?: PromiseOrValue<BytesLike> | null
    ): CreatedDisputeEventFilter;

    'Dispute(address,uint256,uint256,uint256)'(
      _arbitrator?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _metaEvidenceID?: null,
      _evidenceGroupID?: null
    ): DisputeEventFilter;
    Dispute(
      _arbitrator?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _metaEvidenceID?: null,
      _evidenceGroupID?: null
    ): DisputeEventFilter;

    'Evidence(address,uint256,address,string)'(
      _arbitrator?: PromiseOrValue<string> | null,
      _evidenceGroupID?: PromiseOrValue<BigNumberish> | null,
      _party?: PromiseOrValue<string> | null,
      _evidence?: null
    ): EvidenceEventFilter;
    Evidence(
      _arbitrator?: PromiseOrValue<string> | null,
      _evidenceGroupID?: PromiseOrValue<BigNumberish> | null,
      _party?: PromiseOrValue<string> | null,
      _evidence?: null
    ): EvidenceEventFilter;

    'MetaEvidence(uint256,string)'(
      _metaEvidenceID?: PromiseOrValue<BigNumberish> | null,
      _evidence?: null
    ): MetaEvidenceEventFilter;
    MetaEvidence(_metaEvidenceID?: PromiseOrValue<BigNumberish> | null, _evidence?: null): MetaEvidenceEventFilter;

    'Ruling(address,uint256,uint256)'(
      _arbitrator?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _ruling?: null
    ): RulingEventFilter;
    Ruling(
      _arbitrator?: PromiseOrValue<string> | null,
      _disputeID?: PromiseOrValue<BigNumberish> | null,
      _ruling?: null
    ): RulingEventFilter;

    'SubmittedEvidenceToKlerosArbitrator(address,uint256,string)'(
      sender?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      evidence?: null
    ): SubmittedEvidenceToKlerosArbitratorEventFilter;
    SubmittedEvidenceToKlerosArbitrator(
      sender?: PromiseOrValue<string> | null,
      disputeId?: PromiseOrValue<BigNumberish> | null,
      evidence?: null
    ): SubmittedEvidenceToKlerosArbitratorEventFilter;
  };

  estimateGas: {
    appealCost(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    appealKlerosArbitratorRuling(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    appealPeriod(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    arbitrationCost(overrides?: CallOverrides): Promise<BigNumber>;

    claimHashToDisputeIdPlusOne(arg0: PromiseOrValue<BytesLike>, overrides?: CallOverrides): Promise<BigNumber>;

    claimsManager(overrides?: CallOverrides): Promise<BigNumber>;

    courts(subcourtID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    createDispute(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    currentRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    disputeIdToClaimDetails(arg0: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    disputeStatus(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    disputes(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    executeRuling(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getSubcourt(subcourtID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;

    klerosArbitrator(overrides?: CallOverrides): Promise<BigNumber>;

    klerosArbitratorExtraData(overrides?: CallOverrides): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rule(
      disputeId: PromiseOrValue<BigNumberish>,
      ruling: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitEvidenceToKlerosArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    appealCost(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    appealKlerosArbitratorRuling(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    appealPeriod(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    arbitrationCost(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    claimHashToDisputeIdPlusOne(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimsManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    courts(subcourtID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createDispute(
      policyHash: PromiseOrValue<BytesLike>,
      claimant: PromiseOrValue<string>,
      claimAmountInUsd: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    currentRuling(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    disputeIdToClaimDetails(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    disputeStatus(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    disputes(disputeId: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    executeRuling(
      disputeId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getSubcourt(subcourtID: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    klerosArbitrator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    klerosArbitratorExtraData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rule(
      disputeId: PromiseOrValue<BigNumberish>,
      ruling: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitEvidenceToKlerosArbitrator(
      disputeId: PromiseOrValue<BigNumberish>,
      evidence: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
