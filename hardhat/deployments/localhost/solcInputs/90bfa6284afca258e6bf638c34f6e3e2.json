{
  "language": "Solidity",
  "sources": {
    "contracts/pool-contracts-symlink/Api3Pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./TimelockUtils.sol\";\nimport \"./interfaces/IApi3Pool.sol\";\n\n/// @title API3 pool contract\n/// @notice Users can stake API3 tokens at the pool contract to be granted\n/// shares. These shares are exposed to the Aragon-based DAO with a\n/// pseudo-MiniMe token interface, giving the user voting power at the DAO.\n/// Staking pays out weekly rewards that get unlocked after a year, and staked\n/// funds are used to collateralize an insurance product that is outside the\n/// scope of this contract.\n/// @dev Functionalities of the contract are distributed to files that form a\n/// chain of inheritance:\n/// (1) Api3Pool.sol\n/// (2) TimelockUtils.sol\n/// (3) ClaimUtils.sol\n/// (4) StakeUtils.sol\n/// (5) TransferUtils.sol\n/// (6) DelegationUtils.sol\n/// (7) RewardUtils.sol\n/// (8) GetterUtils.sol\n/// (9) StateUtils.sol\ncontract Api3Pool is TimelockUtils, IApi3Pool {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        StateUtils(api3TokenAddress)\n    {}\n}\n"
    },
    "contracts/pool-contracts-symlink/TimelockUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./ClaimUtils.sol\";\nimport \"./interfaces/ITimelockUtils.sol\";\n\n/// @title Contract that implements vesting functionality\n/// @dev TimelockManager contracts interface with this contract to transfer\n/// API3 tokens that are locked under a vesting schedule.\nabstract contract TimelockUtils is ClaimUtils, ITimelockUtils {\n\n    string private constant INVALID_TIME_OR_AMOUNT =\n    \"API3DAO.TimelockUtils: AMOUNT SHOULD BE GREATER THEN 0 AND releaseEnd > releaseStart\";\n    string private constant ERROR_LOCKED_TOKENS = \"API3DAO.TimelockUtils: User shouldn't have timelocked tokens\";\n    string private constant ERROR_BEFORE_RELEASE = \"API3DAO.TimelockUtils: Cannot update status before releaseStart\";\n    string private constant ERROR_ZERO_AMOUNT = \"API3DAO.TimelockUtils: Locked amount should be greater than 0\";\n\n    struct Timelock\n    {\n        uint256 totalAmount;\n        uint256 remainingAmount;\n        uint256 releaseStart;\n        uint256 releaseEnd;\n    }\n\n    /// @notice Maps user addresses to TimelockManager contract addresses to\n    /// timelocks\n    /// @dev This implies that a user cannot have multiple timelocks\n    /// transferrerd from the same TimelockManager contract. This is\n    /// acceptable, because the TimelockManager is implemented in a way to not\n    /// allow multiple timelocks per user.\n    mapping(address => mapping(address => Timelock)) public userToDepositorToTimelock;\n\n    /// @notice Called by TimelockManager contracts to deposit tokens on behalf\n    /// of a user on a linear vesting schedule\n    /// @dev Refer to `TimelockManager.sol` to see how this is used\n    /// @param source Token source\n    /// @param amount Token amount\n    /// @param userAddress Address of the user who will receive the tokens\n    /// @param releaseStart Vesting schedule starting time\n    /// @param releaseEnd Vesting schedule ending time\n    function depositWithVesting(\n        address source,\n        uint256 amount,\n        address userAddress,\n        uint256 releaseStart,\n        uint256 releaseEnd\n        )\n        external\n        override\n    {\n        require(userToDepositorToTimelock[userAddress][msg.sender].remainingAmount == 0, ERROR_LOCKED_TOKENS);\n        require(\n            releaseEnd > releaseStart\n                && amount != 0,\n            INVALID_TIME_OR_AMOUNT\n            );\n        users[userAddress].unstaked = users[userAddress].unstaked + amount;\n        users[userAddress].vesting = users[userAddress].vesting + amount;\n        userToDepositorToTimelock[userAddress][msg.sender] = Timelock({\n            totalAmount: amount,\n            remainingAmount: amount,\n            releaseStart: releaseStart,\n            releaseEnd: releaseEnd\n            });\n        api3Token.transferFrom(source, address(this), amount);\n        emit DepositedVesting(\n            userAddress,\n            amount,\n            releaseStart,\n            releaseEnd\n            );\n    }\n\n    /// @notice Called to release tokens vested by the timelock\n    /// @param userAddress Address of the user whose timelock status will be\n    /// updated\n    /// @param timelockManagerAddress Address of the TimelockManager that has\n    /// created the timelock\n    function updateTimelockStatus(\n        address userAddress,\n        address timelockManagerAddress\n        )\n        external\n        override\n    {\n        Timelock storage timelock = userToDepositorToTimelock[userAddress][timelockManagerAddress];\n        require(block.timestamp > timelock.releaseStart, ERROR_BEFORE_RELEASE);\n        require(timelock.remainingAmount > 0, ERROR_ZERO_AMOUNT);\n        uint256 totalUnlocked;\n        if (block.timestamp >= timelock.releaseEnd)\n        {\n            totalUnlocked = timelock.totalAmount;\n        }\n        else\n        {\n            uint256 passedTime = block.timestamp - timelock.releaseStart;\n            uint256 totalTime = timelock.releaseEnd - timelock.releaseStart;\n            totalUnlocked = timelock.totalAmount * passedTime / totalTime;\n        }\n        uint256 previouslyUnlocked = timelock.totalAmount - timelock.remainingAmount;\n        uint256 newlyUnlocked = totalUnlocked - previouslyUnlocked;\n        User storage user = users[userAddress];\n        user.vesting = user.vesting - newlyUnlocked;\n        uint256 newRemainingAmount = timelock.remainingAmount - newlyUnlocked;\n        userToDepositorToTimelock[userAddress][timelockManagerAddress].remainingAmount = newRemainingAmount;\n        emit UpdatedTimelock(\n            userAddress,\n            timelockManagerAddress,\n            newRemainingAmount\n            );\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IApi3Pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./ITimelockUtils.sol\";\n\ninterface IApi3Pool is ITimelockUtils {\n}\n"
    },
    "contracts/pool-contracts-symlink/ClaimUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./StakeUtils.sol\";\nimport \"./interfaces/IClaimUtils.sol\";\n\n/// @title Contract that implements the insurance claim payout functionality\nabstract contract ClaimUtils is StakeUtils, IClaimUtils {\n\n\n    string private constant ERROR_CLAIM_AMOUNT = \"API3DAO.ClaimUtils: Total stake should be bigger then claim amount\";\n    string private constant ERROR_CLAIM_MANAGER = \"API3DAO.ClaimUtils: Only claim manager is allowed to perform this action\";\n\n    /// @dev Reverts if the caller is not a claims manager\n    modifier onlyClaimsManager() {\n        require(claimsManagerStatus[msg.sender], ERROR_CLAIM_MANAGER);\n        _;\n    }\n\n    /// @notice Called by a claims manager to pay out an insurance claim\n    /// @dev The claims manager is a trusted contract that is allowed to\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\n    /// claims. Any kind of limiting logic (e.g., maximum amount of tokens that\n    /// can be withdrawn) is implemented at its end and is out of the scope of\n    /// this contract.\n    /// This will revert if the pool does not have enough funds.\n    /// @param recipient Recipient of the claim\n    /// @param amount Amount of tokens that will be paid out\n    function payOutClaim(\n        address recipient,\n        uint256 amount\n        )\n        external\n        override\n        onlyClaimsManager()\n    {\n        payReward();\n        // totalStake should not go lower than 1\n        require(totalStake > amount, ERROR_CLAIM_AMOUNT);\n        totalStake = totalStake - amount;\n        api3Token.transfer(recipient, amount);\n        emit PaidOutClaim(\n            recipient,\n            amount\n            );\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/ITimelockUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IClaimUtils.sol\";\n\ninterface ITimelockUtils is IClaimUtils {\n    event DepositedVesting(\n        address indexed user,\n        uint256 amount,\n        uint256 start,\n        uint256 end\n        );\n\n    event UpdatedTimelock(\n        address indexed user,\n        address indexed timelockManagerAddress,\n        uint256 remainingAmount\n        );\n\n    function depositWithVesting(\n        address source,\n        uint256 amount,\n        address userAddress,\n        uint256 releaseStart,\n        uint256 releaseEnd\n        )\n        external;\n\n    function updateTimelockStatus(\n        address userAddress,\n        address timelockManagerAddress\n        )\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/StakeUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./TransferUtils.sol\";\nimport \"./interfaces/IStakeUtils.sol\";\n\n/// @title Contract that implements staking functionality\nabstract contract StakeUtils is TransferUtils, IStakeUtils {\n\n\n    string private constant ERROR_NOT_ENOUGH_FUNDS = \"API3DAO.StakeUtils: User don't have enough token to stake/unstake the provided amount\";\n    string private constant ERROR_NOT_ENOUGH_SHARES = \"API3DAO.StakeUtils: User don't have enough pool shares to unstake the provided amount\";\n    string private constant ERROR_UNSTAKE_TIMING = \"API3DAO.StakeUtils: Scheduled unstake has not matured yet\";\n    string private constant ERROR_STAKING_ADDRESS = \"API3DAO.StakeUtils: It is only possible to stake to yourself\";\n    string private constant ERROR_ALREADY_SCHEDULED = \"API3DAO.StakeUtils: User has already scheduled an unstake\";\n    string private constant ERROR_NO_SCHEDULED = \"API3DAO.StakeUtils: User has no scheduled unstake to execute\";\n\n    /// @notice Called to stake tokens to receive pools in the share\n    /// @param amount Amount of tokens to stake\n    function stake(uint256 amount)\n        public\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        require(user.unstaked >= amount, ERROR_NOT_ENOUGH_FUNDS);\n        user.unstaked = user.unstaked - amount;\n        uint256 totalSharesNow = totalShares();\n        uint256 sharesToMint = totalSharesNow * amount / totalStake;\n        uint256 userSharesNow = userShares(msg.sender);\n        user.shares.push(Checkpoint({\n            fromBlock: block.number,\n            value: userSharesNow + sharesToMint\n            }));\n        uint256 totalSharesAfter = totalSharesNow + sharesToMint;\n        updateTotalShares(totalSharesAfter);\n        totalStake = totalStake + amount;\n        updateDelegatedVotingPower(msg.sender, sharesToMint, true);\n        emit Staked(\n            msg.sender,\n            amount,\n            totalSharesAfter\n            );\n    }\n\n    /// @notice Convenience method to deposit and stake in a single transaction\n    /// @dev Due to the `deposit()` interface, `userAddress` can only be the\n    /// caller\n    /// @param source Token transfer source\n    /// @param amount Amount to be deposited and staked\n    function depositAndStake(\n        address source,\n        uint256 amount\n        )\n        external\n        override\n    {\n        deposit(source, amount, msg.sender);\n        stake(amount);\n    }\n\n    /// @notice Called by the user to schedule unstaking of their tokens\n    /// @dev While scheduling an unstake, `shares` get deducted from the user,\n    /// meaning that they will not receive rewards or voting power for them any\n    /// longer.\n    /// At unstaking-time, the user unstakes either the amount of tokens\n    /// `shares` corresponds to at scheduling-time, or the amount of tokens\n    /// `shares` corresponds to at unstaking-time, whichever is smaller. This\n    /// corresponds to tokens being scheduled to be unstaked not receiving any\n    /// rewards, but being subject to claim payouts.\n    /// In the instance that a claim has been paid out before an unstaking is\n    /// executed, the user may potentially receive rewards during\n    /// `unstakeWaitPeriod` (but not if there has not been a claim payout) but\n    /// the amount of tokens that they can unstake will not be able to exceed\n    /// the amount they scheduled the unstaking for.\n    /// @param shares Amount of shares to be burned to unstake tokens\n    function scheduleUnstake(uint256 shares)\n        external\n        override\n    {\n        payReward();\n        uint256 userSharesNow = userShares(msg.sender);\n        require(\n            userSharesNow >= shares,\n            ERROR_NOT_ENOUGH_SHARES\n            );\n        User storage user = users[msg.sender];\n        require(user.unstakeScheduledFor == 0, ERROR_ALREADY_SCHEDULED);\n        uint256 amount = shares * totalStake / totalShares();\n        user.unstakeScheduledFor = block.timestamp + unstakeWaitPeriod;\n        user.unstakeAmount = amount;\n        user.unstakeShares = shares;\n        user.shares.push(Checkpoint({\n            fromBlock: block.number,\n            value: userSharesNow - shares\n            }));\n        updateDelegatedVotingPower(msg.sender, shares, false);\n        emit ScheduledUnstake(\n            msg.sender,\n            shares,\n            amount,\n            user.unstakeScheduledFor\n            );\n    }\n\n    /// @notice Called to execute a pre-scheduled unstake\n    /// @dev Anyone can execute a mature scheduled unstake\n    /// @param userAddress Address of the user whose scheduled unstaking will\n    /// be executed\n    /// @return Amount of tokens that are unstaked\n    function unstake(address userAddress)\n        public\n        override\n        returns(uint256)\n    {\n        payReward();\n        User storage user = users[userAddress];\n        require(user.unstakeScheduledFor != 0, ERROR_NO_SCHEDULED);\n        require(user.unstakeScheduledFor < block.timestamp, ERROR_UNSTAKE_TIMING);\n\n        uint256 totalShares = totalShares();\n        uint256 unstakeAmountAtSchedulingTime = user.unstakeAmount;\n        uint256 unstakeAmountByShares = user.unstakeShares * totalStake / totalShares;\n        uint256 unstakeAmount = unstakeAmountAtSchedulingTime > unstakeAmountByShares\n            ? unstakeAmountByShares\n            : unstakeAmountAtSchedulingTime;\n        unstakeAmount = unstakeAmount < totalStake ? unstakeAmount : totalStake - 1;\n        user.unstaked = user.unstaked + unstakeAmount;\n\n        updateTotalShares(totalShares - user.unstakeShares);\n        totalStake = totalStake - unstakeAmount;\n\n        user.unstakeShares = 0;\n        user.unstakeAmount = 0;\n        user.unstakeScheduledFor = 0;      \n        emit Unstaked(\n            userAddress,\n            unstakeAmount\n            );\n        return unstakeAmount;\n    }\n\n    /// @notice Convenience method to execute an unstake and withdraw in a\n    /// single transaction\n    /// @dev Note that withdraw may revert because the user may have less than\n    /// `unstaked` tokens that are withdrawable\n    /// @param destination Token transfer destination\n    function unstakeAndWithdraw(address destination)\n        external\n        override\n    {\n        uint256 unstaked = unstake(msg.sender);\n        withdraw(destination, unstaked);\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IClaimUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IStakeUtils.sol\";\n\ninterface IClaimUtils is IStakeUtils {\n    event PaidOutClaim(\n        address indexed recipient,\n        uint256 amount\n        );\n\n    function payOutClaim(\n        address recipient,\n        uint256 amount\n        )\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/TransferUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./DelegationUtils.sol\";\nimport \"./interfaces/ITransferUtils.sol\";\n\n/// @title Contract that implements token transfer functionality\nabstract contract TransferUtils is DelegationUtils, ITransferUtils {\n\n    string private constant WRONG_TOTAL_FUNDS =\n    \"API3DAO.TransferUtils: User total funds should be bigger then locked and amount to withdraw\";\n    string private constant AMOUNT_TOO_BIG =\n    \"API3DAO.TransferUtils: Withdrawal amount should be less or equal to the unstaked tokens\";\n\n    /// @notice Called to deposit tokens for a user by using `transferFrom()`\n    /// @dev This method is used by `TimelockManager.sol`\n    /// @param source Token transfer source\n    /// @param amount Amount to be deposited\n    /// @param userAddress User that the tokens will be deposited for\n    function deposit(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        public\n        override\n    {\n        payReward();\n        users[userAddress].unstaked = users[userAddress].unstaked + amount;\n        api3Token.transferFrom(source, address(this), amount);\n        emit Deposited(\n            userAddress,\n            amount\n            );\n    }\n\n    /// @notice Called to withdraw tokens\n    /// @dev The user should call `getUserLocked()` beforehand to ensure that\n    /// they have at least `amount` unlocked tokens to withdraw\n    /// @param destination Token transfer destination\n    /// @param amount Amount to be withdrawn\n    function withdraw(\n        address destination,\n        uint256 amount\n        )\n        public\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        uint256 userLocked = getUserLocked(msg.sender);\n        // Check if the user has `amount` unlocked tokens to withdraw\n        uint256 lockedAndVesting = userLocked + user.vesting;\n        uint256 userTotalFunds = user.unstaked + userStake(msg.sender);\n        require(userTotalFunds >= lockedAndVesting + amount, WRONG_TOTAL_FUNDS);\n        // Carry on with the withdrawal\n        require(user.unstaked >= amount, AMOUNT_TOO_BIG);\n        user.unstaked = user.unstaked - amount;\n        api3Token.transfer(destination, amount);\n        emit Withdrawn(msg.sender,\n            destination,\n            amount\n            );\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IStakeUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./ITransferUtils.sol\";\n\ninterface IStakeUtils is ITransferUtils{\n    event Staked(\n        address indexed user,\n        uint256 amount,\n        uint256 totalShares\n        );\n\n    event ScheduledUnstake(\n        address indexed user,\n        uint256 shares,\n        uint256 amount,\n        uint256 scheduledFor\n        );\n\n    event Unstaked(\n        address indexed user,\n        uint256 amount\n        );\n\n    function stake(uint256 amount)\n        external;\n\n    function depositAndStake(\n        address source,\n        uint256 amount\n        )\n        external;\n\n    function scheduleUnstake(uint256 shares)\n        external;\n\n    function unstake(address userAddress)\n        external\n        returns(uint256);\n\n    function unstakeAndWithdraw(address destination)\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/DelegationUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./RewardUtils.sol\";\nimport \"./interfaces/IDelegationUtils.sol\";\n\n/// @title Contract that implements voting power delegation\nabstract contract DelegationUtils is RewardUtils, IDelegationUtils {\n\n    string internal constant ERROR_DELEGATION_BALANCE = \"API3DAO.DelegationUtils: Cannot delegate zero shares\";\n    string internal constant ERROR_DELEGATION_ADRESSES =\n    \"API3DAO.DelegationUtils: Cannot delegate to yourself or zero address and if you've already delegated\";\n    string internal constant ERROR_DELEGATED_RECENTLY =\n    \"API3DAO.DelegationUtils: This address un/delegated less than a week before\";\n    string internal constant ERROR_ACTIVE_RECENTLY =\n    \"API3DAO.DelegationUtils: This address voted or made a proposal less than a week before\";\n    string internal constant ERROR_NOT_DELEGATED =\n    \"API3DAO.DelegationUtils: This address has not delegated\";\n\n    /// @notice Called by the user to delegate voting power\n    /// @param delegate User address the voting power will be delegated to\n    function delegateVotingPower(address delegate)\n        external\n        override\n    {\n        payReward();\n        // Delegating users cannot use their voting power, so we verify that\n        // the delegate is not currently delegating. However,\n        // the delegate may delegate after they have been delegated to.\n        require(\n            delegate != address(0)\n                && delegate != msg.sender\n                && getUserDelegate(delegate) == address(0),\n                ERROR_DELEGATION_ADRESSES\n            );\n        User storage user = users[msg.sender];\n        // Do not allow frequent delegation updates as that can be used to spam\n        // proposals\n        require(\n            user.mostRecentDelegationTimestamp <= block.timestamp - EPOCH_LENGTH\n                && user.mostRecentUndelegationTimestamp <= block.timestamp - EPOCH_LENGTH,\n                ERROR_DELEGATED_RECENTLY\n            );\n        // Do not allow the user to delegate if they have voted or made a proposal\n        // in the last epoch to prevent double voting\n        require(\n            user.mostRecentProposalTimestamp <= block.timestamp - EPOCH_LENGTH\n                && user.mostRecentVoteTimestamp <= block.timestamp - EPOCH_LENGTH,\n                ERROR_ACTIVE_RECENTLY\n            );\n        user.mostRecentDelegationTimestamp = block.timestamp;\n        uint256 userShares = userShares(msg.sender);\n        address userDelegate = getUserDelegate(msg.sender);\n        require(userShares > 0, ERROR_DELEGATION_BALANCE );\n        require(userDelegate != delegate, ERROR_DELEGATE);\n\n        if (userDelegate != address(0)) {\n            // Revoke previous delegation\n            updateCheckpointArray(\n                users[userDelegate].delegatedTo,\n                userReceivedDelegation(userDelegate) - userShares\n                );\n            emit Undelegated(\n                msg.sender,\n                userDelegate\n            );\n        }\n        // Assign the new delegation\n        User storage _delegate = users[delegate];\n        updateCheckpointArray(\n            _delegate.delegatedTo,\n            userReceivedDelegation(delegate) + userShares\n            );\n        // Record the new delegate for the user\n        updateAddressCheckpointArray(\n            user.delegates,\n            delegate\n            );\n        emit Delegated(\n            msg.sender,\n            delegate\n            );\n    }\n\n    /// @notice Called by the user to undelegate voting power\n    function undelegateVotingPower()\n        external\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        address userDelegate = getUserDelegate(msg.sender);\n        require(userDelegate != address(0), ERROR_NOT_DELEGATED);\n        // Do not allow frequent delegation updates as that can be used to spam\n        // proposals\n        require(\n            user.mostRecentDelegationTimestamp <= block.timestamp - EPOCH_LENGTH\n                && user.mostRecentUndelegationTimestamp <= block.timestamp - EPOCH_LENGTH,\n            ERROR_DELEGATED_RECENTLY\n            );\n\n        uint256 userShares = userShares(msg.sender);\n        User storage delegate = users[userDelegate];\n        updateCheckpointArray(\n            delegate.delegatedTo,\n            userReceivedDelegation(userDelegate) - userShares\n            );\n        updateAddressCheckpointArray(\n            user.delegates,\n            address(0)\n            );\n        user.mostRecentUndelegationTimestamp = block.timestamp;\n        emit Undelegated(\n            msg.sender,\n            userDelegate\n            );\n    }\n\n    /// @notice Called internally when the user shares are updated to update\n    /// the delegated voting power\n    /// @dev User shares only get updated while staking or scheduling unstaking\n    /// @param userAddress Address of the user whose delegated voting power\n    /// will be updated\n    /// @param shares Amount of shares that will be added/removed\n    /// @param delta Whether the shares will be added/removed (add for `true`,\n    /// and vice versa)\n    function updateDelegatedVotingPower(\n        address userAddress,\n        uint256 shares,\n        bool delta\n        )\n        internal\n    {\n        address userDelegate = getUserDelegate(userAddress);\n        if (userDelegate == address(0)) {\n            return;\n        }\n\n        User storage delegate = users[userDelegate];\n        uint256 currentlyDelegatedTo = userReceivedDelegation(userDelegate);\n        uint256 newDelegatedTo;\n        if (delta) {\n            newDelegatedTo = currentlyDelegatedTo + shares;\n        } else {\n            newDelegatedTo = currentlyDelegatedTo > shares\n                ? currentlyDelegatedTo - shares\n                : 0;\n        }\n        updateCheckpointArray(\n            delegate.delegatedTo,\n            newDelegatedTo\n            );\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/ITransferUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IDelegationUtils.sol\";\n\ninterface ITransferUtils is IDelegationUtils{\n    event Deposited(\n        address indexed user,\n        uint256 amount\n        );\n\n    event Withdrawn(\n        address indexed user,\n        address indexed destination,\n        uint256 amount\n        );\n\n    function deposit(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        external;\n\n    function withdraw(\n        address destination,\n        uint256 amount\n        )\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/RewardUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./GetterUtils.sol\";\nimport \"./interfaces/IRewardUtils.sol\";\n\n/// @title Contract that implements reward payments and locks\nabstract contract RewardUtils is GetterUtils, IRewardUtils {\n    /// @notice Called to pay the reward for the current epoch\n    /// @dev Skips past epochs for which rewards have not been paid for.\n    /// Skips the reward payment if the pool is not authorized to mint tokens.\n    /// Neither of these conditions will occur in practice.\n    function payReward()\n        public\n        override\n    {\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        // This will be skipped in most cases because someone else will have\n        // triggered the payment for this epoch\n        if (epochIndexOfLastRewardPayment < currentEpoch)\n        {\n            if (api3Token.getMinterStatus(address(this)))\n            {\n                updateCurrentApr();\n                uint256 rewardAmount = totalStake * currentApr / REWARD_VESTING_PERIOD / HUNDRED_PERCENT;\n                epochIndexToReward[currentEpoch] = Reward({\n                    atBlock: block.number,\n                    amount: rewardAmount,\n                    totalSharesThen: totalShares()\n                    });\n                api3Token.mint(address(this), rewardAmount);\n                totalStake = totalStake + rewardAmount;\n                emit PaidReward(\n                    currentEpoch,\n                    rewardAmount,\n                    currentApr\n                    );\n            }\n            epochIndexOfLastRewardPayment = currentEpoch;\n        }\n    }\n\n    /// @notice Updates the current APR\n    /// @dev Called internally before paying out the reward\n    function updateCurrentApr()\n        internal\n    {\n        uint256 totalStakePercentage = totalStake\n            * HUNDRED_PERCENT\n            / api3Token.totalSupply();\n        if (totalStakePercentage > stakeTarget) {\n            currentApr = currentApr > aprUpdateStep ? currentApr - aprUpdateStep : 0;\n        }\n        else {\n            currentApr += aprUpdateStep;\n        }\n        if (currentApr > maxApr) {\n            currentApr = maxApr;\n        }\n        else if (currentApr < minApr) {\n            currentApr = minApr;\n        }\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IDelegationUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IRewardUtils.sol\";\n\ninterface IDelegationUtils is IRewardUtils {\n    event Delegated(\n        address indexed user,\n        address indexed delegate\n        );\n\n    event Undelegated(\n        address indexed user,\n        address indexed delegate\n        );\n\n    function delegateVotingPower(address delegate) \n        external;\n\n    function undelegateVotingPower()\n        external;\n\n    \n}\n"
    },
    "contracts/pool-contracts-symlink/GetterUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./StateUtils.sol\";\nimport \"./interfaces/IGetterUtils.sol\";\n\n/// @title Contract that implements getters\nabstract contract GetterUtils is StateUtils, IGetterUtils {\n\n    string private constant CHECKPOINT_NOT_FOUND = \"API3DAO.GetterUtils: Value cannot be found after provided checkpoint\";\n\n    /// @notice Called to get the voting power of a user at a checkpoint,\n    /// closest to the provided block\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Voting power of the user at the block\n    function balanceOfAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        // Users that delegate have no voting power\n        if (getUserDelegateAt(userAddress, _block) != address(0))\n        {\n            return 0;\n        }\n        uint256 userSharesThen = userSharesAt(userAddress, _block);\n        uint256 delegatedToUserThen = getReceivedDelegationAt(userAddress, _block);\n        return userSharesThen + delegatedToUserThen;\n    }\n\n    /// @notice Called to get the current voting power of a user\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @param userAddress User address\n    /// @return Current voting power of the user\n    function balanceOf(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return balanceOfAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the total voting power one block ago\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @return Total voting power one block ago\n    function totalSupplyOneBlockAgo()\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return totalSharesOneBlockAgo();\n    }\n\n    /// @notice Called to get the current total voting power\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Aragon Voting app\n    /// @return Current total voting power\n    function totalSupply()\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return totalShares();\n    }\n\n    /// @notice Called to get the pool shares of a user at a checkpoint,\n    /// closest to the provided block\n    /// @dev Starts from the most recent value in `user.shares` and searches\n    /// backwards one element at a time\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Pool shares of the user at the block\n    function userSharesAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return getValueAt(users[userAddress].shares, _block, 0);\n    }\n\n    /// @notice Called to get the current pool shares of a user\n    /// @param userAddress User address\n    /// @return Current pool shares of the user\n    function userShares(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return userSharesAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the pool shares of a user at checkpoint,\n    /// closest to specific block using binary search\n    /// @dev This method is not used by the current iteration of the DAO/pool\n    /// and is implemented for future external contracts to use to get the user\n    /// shares at an arbitrary block.\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Pool shares of the user at the block\n    function userSharesAtWithBinarySearch(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        override\n        returns(uint256)\n    {\n        return getValueAtWithBinarySearch(\n            users[userAddress].shares,\n            _block,\n            0\n            );\n    }\n\n    /// @notice Called to get the current staked tokens of the user\n    /// @param userAddress User address\n    /// @return Current staked tokens of the user\n    function userStake(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return userShares(userAddress) * totalStake / totalShares();\n    }\n\n    /// @notice Called to get the voting power delegated to a user at a\n    /// checkpoint, closest to specific block\n    /// @dev `user.delegatedTo` cannot have grown more than 1000 checkpoints\n    /// in the last epoch due to `proposalVotingPowerThreshold` having a lower\n    /// limit of 0.1%.\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Voting power delegated to the user at the block\n    function getReceivedDelegationAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        // Binary searching a 1000-long array takes up to 10 storage reads\n        // (2^10 = 1024). If we approximate the average number of reads\n        // required to be 5 and consider that it is much more likely for the\n        // value we are looking for will be at the end of the array (because\n        // not many proposals will be made per epoch), it is preferable to do\n        // a linear search at the end of the array if possible. Here, the\n        // length of \"the end of the array\" is specified to be 5 (which was the\n        // expected number of iterations we will need for a binary search).\n        uint256 maximumLengthToLinearSearch = 5;\n        // If the value we are looking for is not among the last\n        // `maximumLengthToLinearSearch`, we will fall back to binary search.\n        // Here, we will only search through the last 1000 checkpoints because\n        // `user.delegatedTo` cannot have grown more than 1000 checkpoints in\n        // the last epoch due to `proposalVotingPowerThreshold` having a lower\n        // limit of 0.1%.\n        uint256 maximumLengthToBinarySearch = 1000;\n        Checkpoint[] storage delegatedTo = users[userAddress].delegatedTo;\n        if (delegatedTo.length < maximumLengthToLinearSearch) {\n            return getValueAt(delegatedTo, _block, 0);\n        }\n        uint256 minimumCheckpointIndexLinearSearch = delegatedTo.length - maximumLengthToLinearSearch;\n        if (delegatedTo[minimumCheckpointIndexLinearSearch].fromBlock < _block) {\n            return getValueAt(delegatedTo, _block, minimumCheckpointIndexLinearSearch);\n        }\n        // It is very unlikely for the method to not have returned until here\n        // because it means there have been `maximumLengthToLinearSearch`\n        // proposals made in the current epoch.\n        uint256 minimumCheckpointIndexBinarySearch = delegatedTo.length > maximumLengthToBinarySearch\n            ? delegatedTo.length - maximumLengthToBinarySearch\n            : 0;\n        // The below will revert if the value being searched is not within the\n        // last `minimumCheckpointIndexBinarySearch` (which is not possible if\n        // `_block` is the snapshot block of an open vote of Api3Voting,\n        // because its vote duration is `EPOCH_LENGTH`).\n        return getValueAtWithBinarySearch(delegatedTo, _block, minimumCheckpointIndexBinarySearch);\n    }\n\n    /// @notice Called to get the current voting power delegated to a user\n    /// @param userAddress User address\n    /// @return Current voting power delegated to the user\n    function userReceivedDelegation(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return getReceivedDelegationAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the delegate of the user at a checkpoint,\n    /// closest to specified block\n    /// @dev Starts from the most recent value in `user.delegates` and\n    /// searches backwards one element at a time. If `_block` is within\n    /// `EPOCH_LENGTH`, this call is guaranteed to find the value among\n    /// the last 2 elements because a user cannot update delegate more\n    /// frequently than once an `EPOCH_LENGTH`.\n    /// @param userAddress User address\n    /// @param _block Block number\n    /// @return Delegate of the user at the specific block\n    function getUserDelegateAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(address)\n    {\n        AddressCheckpoint[] storage delegates = users[userAddress].delegates;\n        for (uint256 i = delegates.length; i > 0; i--)\n        {\n            if (delegates[i - 1].fromBlock <= _block)\n            {\n                return delegates[i - 1]._address;\n            }\n        }\n        return address(0);\n    }\n\n    /// @notice Called to get the current delegate of the user\n    /// @param userAddress User address\n    /// @return Current delegate of the user\n    function getUserDelegate(address userAddress)\n        public\n        view\n        override\n        returns(address)\n    {\n        return getUserDelegateAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the current locked tokens of the user\n    /// @param userAddress User address\n    /// @return locked Current locked tokens of the user\n    function getUserLocked(address userAddress)\n        public\n        view\n        override\n        returns(uint256 locked)\n    {\n        Checkpoint[] storage _userShares = users[userAddress].shares;\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        uint256 oldestLockedEpoch = currentEpoch - REWARD_VESTING_PERIOD > genesisEpoch\n            ? currentEpoch - REWARD_VESTING_PERIOD + 1\n            : genesisEpoch + 1;\n\n        if (_userShares.length == 0)\n        {\n            return 0;\n        }\n        uint256 indUserShares = _userShares.length - 1;\n        for (\n                uint256 indEpoch = currentEpoch;\n                indEpoch >= oldestLockedEpoch;\n                indEpoch--\n            )\n        {\n            Reward storage lockedReward = epochIndexToReward[indEpoch];\n            if (lockedReward.atBlock != 0)\n            {\n                for (; indUserShares >= 0; indUserShares--)\n                {\n                    Checkpoint storage userShare = _userShares[indUserShares];\n                    if (userShare.fromBlock <= lockedReward.atBlock)\n                    {\n                        locked += lockedReward.amount * userShare.value / lockedReward.totalSharesThen;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Called to get the details of a user\n    /// @param userAddress User address\n    /// @return unstaked Amount of unstaked API3 tokens\n    /// @return vesting Amount of API3 tokens locked by vesting\n    /// @return unstakeShares Shares scheduled to unstake\n    /// @return unstakeAmount Amount scheduled to unstake\n    /// @return unstakeScheduledFor Time unstaking is scheduled for\n    /// @return mostRecentProposalTimestamp Time when the user made their most\n    /// recent proposal\n    /// @return mostRecentVoteTimestamp Time when the user cast their most\n    /// recent vote\n    /// @return mostRecentDelegationTimestamp Time when the user made their\n    /// most recent delegation\n    /// @return mostRecentUndelegationTimestamp Time when the user made their\n    /// most recent undelegation\n    function getUser(address userAddress)\n        external\n        view\n        override\n        returns(\n            uint256 unstaked,\n            uint256 vesting,\n            uint256 unstakeShares,\n            uint256 unstakeAmount,\n            uint256 unstakeScheduledFor,\n            uint256 mostRecentProposalTimestamp,\n            uint256 mostRecentVoteTimestamp,\n            uint256 mostRecentDelegationTimestamp,\n            uint256 mostRecentUndelegationTimestamp\n            )\n    {\n        User storage user = users[userAddress];\n        unstaked = user.unstaked;\n        vesting = user.vesting;\n        unstakeShares = user.unstakeShares;\n        unstakeAmount = user.unstakeAmount;\n        unstakeScheduledFor = user.unstakeScheduledFor;\n        mostRecentProposalTimestamp = user.mostRecentProposalTimestamp;\n        mostRecentVoteTimestamp = user.mostRecentVoteTimestamp;\n        mostRecentDelegationTimestamp = user.mostRecentDelegationTimestamp;\n        mostRecentUndelegationTimestamp = user.mostRecentUndelegationTimestamp;\n    }\n\n    /// @notice Called to get the value of a checkpoint array closest to\n    /// the specific block\n    /// @param checkpoints Checkpoints array\n    /// @param _block Block number for which the query is being made\n    /// @return Value of the checkpoint array at the block\n    function getValueAt(\n        Checkpoint[] storage checkpoints,\n        uint256 _block,\n        uint256 minimumCheckpointIndex\n        )\n        internal\n        view\n        returns(uint256)\n    {\n        uint256 i = checkpoints.length;\n        for (; i > minimumCheckpointIndex; i--)\n        {\n            if (checkpoints[i - 1].fromBlock <= _block)\n            {\n                return checkpoints[i - 1].value;\n            }\n        }\n        // Revert if the value being searched for comes before\n        // `minimumCheckpointIndex`\n        require(i == 0, CHECKPOINT_NOT_FOUND);\n        return 0;\n    }\n\n    /// @notice Called to get the value of the checkpoint array  closest to the\n    /// specific block\n    /// @dev Adapted from\n    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\n    /// Allows the caller to specify the portion of the array that will be\n    /// searched. This allows us to avoid having to search arrays that can grow\n    /// unboundedly.\n    /// @param checkpoints Checkpoint array\n    /// @param _block Block number for which the query is being made\n    /// @param minimumCheckpointIndex Index of the earliest checkpoint that may\n    /// be keeping the value we are looking for\n    /// @return Value of the checkpoint array at `_block`\n    function getValueAtWithBinarySearch(\n        Checkpoint[] storage checkpoints,\n        uint256 _block,\n        uint256 minimumCheckpointIndex\n        )\n        internal\n        view\n        returns(uint256)\n    {\n        if (checkpoints.length == 0)\n            return 0;\n        assert(checkpoints.length > minimumCheckpointIndex);\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length - 1].fromBlock) {\n            return checkpoints[checkpoints.length - 1].value;\n        }\n        // Revert if the value being searched for comes before\n        // `minimumCheckpointIndex`\n        if (_block < checkpoints[minimumCheckpointIndex].fromBlock) {\n            if (minimumCheckpointIndex == 0) {\n                return 0;\n            }\n            else {\n                revert(CHECKPOINT_NOT_FOUND);\n            }\n        }\n\n        // Binary search of the value in the array\n        uint min = minimumCheckpointIndex;\n        uint max = checkpoints.length - 1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IRewardUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IGetterUtils.sol\";\n\ninterface IRewardUtils is IGetterUtils {\n    event PaidReward(\n        uint256 indexed epoch,\n        uint256 rewardAmount,\n        uint256 apr\n        );\n\n    function payReward()\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/StateUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./auxiliary/interfaces/v0.8.4/IApi3Token.sol\";\nimport \"./interfaces/IStateUtils.sol\";\n\n/// @title Contract that keeps state variables\ncontract StateUtils is IStateUtils {\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256 value;\n    }\n\n    struct AddressCheckpoint {\n        uint256 fromBlock;\n        address _address;\n    }\n\n    struct Reward {\n        uint256 atBlock;\n        uint256 amount;\n        uint256 totalSharesThen;\n    }\n\n    struct User {\n        Checkpoint[] shares;\n        AddressCheckpoint[] delegates;\n        Checkpoint[] delegatedTo;\n        uint256 unstaked;\n        uint256 vesting;\n        uint256 unstakeShares;\n        uint256 unstakeAmount;\n        uint256 unstakeScheduledFor;\n        uint256 mostRecentProposalTimestamp;\n        uint256 mostRecentVoteTimestamp;\n        uint256 mostRecentDelegationTimestamp;\n        uint256 mostRecentUndelegationTimestamp;\n    }\n\n    /// @notice Length of the epoch in which the staking reward is paid out\n    /// once. It is hardcoded as 7 days in seconds.\n    /// @dev In addition to regulating reward payments, this variable is used\n    /// for four additional things:\n    /// (1) Once an unstaking scheduling matures, the user has `EPOCH_LENGTH`\n    /// to execute the unstaking before it expires\n    /// (2) After a user makes a proposal, they cannot make a second one\n    /// before `EPOCH_LENGTH` has passed\n    /// (3) After a user updates their delegation status, they have to wait\n    /// `EPOCH_LENGTH` before updating it again\n    uint256 public constant EPOCH_LENGTH = 7 * 24 * 60 * 60;\n\n    /// @notice Number of epochs before the staking rewards get unlocked.\n    /// Hardcoded as 52 epochs, which corresponds to a year.\n    uint256 public constant REWARD_VESTING_PERIOD = 52;\n\n    string internal constant ERROR_PERCENTAGE = \"API3DAO.StateUtils: Percentage should be between 0 and 100\";\n    string internal constant ERROR_APR = \"API3DAO.StateUtils: Max APR should be bigger than min apr\";\n    string internal constant ERROR_UNSTAKE_PERIOD = \"API3DAO.StateUtils: Should wait for time bigger than EPOCH_LENGTH to unstake\";\n    string internal constant ERROR_PROPOSAL_THRESHOLD = \"API3DAO.StateUtils: Threshold should be lower then 10%\";\n    string internal constant ERROR_ZERO_ADDRESS = \"API3DAO.StateUtils: Addresses should not be 0x00\";\n    string internal constant ERROR_ONLY_AGENT = \"API3DAO.StateUtils: Only Agent app is allowed to execute this function\";\n    string internal constant ERROR_ONLY_PRIMARY_AGENT = \"API3DAO.StateUtils: Only primary Agent app is allowed to execute this function\";\n    string internal constant ERROR_ONLY_VOTING = \"API3DAO.StateUtils: Only Voting app is allowed to execute this function\";\n    string internal constant ERROR_FREQUENCY = \"API3DAO.StateUtils: Try again a week later\";\n    string internal constant ERROR_DELEGATE = \"API3DAO.StateUtils: Cannot delegate to the same address\";\n\n    // All percentage values are represented by multiplying by 1e16\n    uint256 internal constant HUNDRED_PERCENT = 1e18;\n    uint256 internal constant ONE_PERCENT = HUNDRED_PERCENT / 100;\n\n    /// @notice API3 token contract\n    IApi3Token public api3Token;\n\n    /// @notice Address of the primary Agent app of the API3 DAO\n    /// @dev Primary Agent can be operated through the primary Api3Voting app.\n    /// The primary Api3Voting app requires a higher quorum, and the primary\n    /// Agent is more privileged.\n    address public agentAppPrimary;\n\n    /// @notice Address of the secondary Agent app of the API3 DAO\n    /// @dev Secondary Agent can be operated through the secondary Api3Voting\n    /// app. The secondary Api3Voting app requires a lower quorum, and the primary\n    /// Agent is less privileged.\n    address public agentAppSecondary;\n\n    /// @notice Address of the primary Api3Voting app of the API3 DAO\n    /// @dev Used to operate the primary Agent\n    address public votingAppPrimary;\n\n    /// @notice Address of the secondary Api3Voting app of the API3 DAO\n    /// @dev Used to operate the secondary Agent\n    address public votingAppSecondary;\n\n    /// @notice Mapping that keeps the claims manager statuses of addresses\n    /// @dev A claims manager is a contract that is authorized to pay out\n    /// claims from the staking pool, effectively slashing the stakers. The\n    /// statuses are kept as a mapping to support multiple claims managers.\n    mapping(address => bool) public claimsManagerStatus;\n\n    /// @notice Epochs are indexed as `block.timestamp / EPOCH_LENGTH`.\n    /// `genesisEpoch` is the index of the epoch in which the pool is deployed.\n    uint256 public immutable genesisEpoch;\n\n    /// @notice Records of rewards paid in each epoch\n    /// @dev `.atBlock` of a past epoch's reward record being `0` means no\n    /// reward was paid for that block\n    mapping(uint256 => Reward) public epochIndexToReward;\n\n    /// @notice Epoch index of the most recent reward payment\n    uint256 public epochIndexOfLastRewardPayment;\n\n    /// @notice User records\n    mapping(address => User) public users;\n\n    /// @notice Total number of tokens staked at the pool\n    uint256 public totalStake;\n\n    /// @notice Stake target the pool will aim to meet in percentages of the\n    /// total token supply. The staking rewards increase if the total staked\n    /// amount is below this, and vice versa.\n    /// @dev Default value is 50% of the total API3 token supply. This\n    /// parameter is governable by the DAO.\n    uint256 public stakeTarget = 50 * ONE_PERCENT;\n\n    /// @notice Minimum APR (annual percentage rate) the pool will pay as\n    /// staking rewards in percentages\n    /// @dev Default value is 2.5%. This parameter is governable by the DAO.\n    uint256 public minApr = 25 * ONE_PERCENT / 10;\n\n    /// @notice Maximum APR (annual percentage rate) the pool will pay as\n    /// staking rewards in percentages\n    /// @dev Default value is 75%. This parameter is governable by the DAO.\n    uint256 public maxApr = 75 * ONE_PERCENT;\n\n    /// @notice Steps in which APR will be updated in percentages\n    /// @dev Default value is 1%. This parameter is governable by the DAO.\n    uint256 public aprUpdateStep = ONE_PERCENT;\n\n    /// @notice Users need to schedule an unstake and wait for\n    /// `unstakeWaitPeriod` before being able to unstake. This is to prevent\n    /// the stakers from frontrunning insurance claims by unstaking to evade\n    /// them, or repeatedly unstake/stake to work around the proposal spam\n    /// protection.\n    /// @dev This parameter is governable by the DAO, and the DAO is expected\n    /// to set this to a value that is large enough to allow insurance claims\n    /// to be resolved.\n    uint256 public unstakeWaitPeriod = EPOCH_LENGTH;\n\n    /// @notice Minimum voting power the users must have to be able to make\n    /// proposals (in percentages)\n    /// @dev Delegations count towards voting power.\n    /// Default value is 0.1%. This parameter is governable by the DAO.\n    uint256 public proposalVotingPowerThreshold = ONE_PERCENT / 10;\n\n    /// @notice APR that will be paid next epoch\n    /// @dev This value will reach an equilibrium based on the stake target.\n    /// Every epoch (week), APR/52 of the total staked tokens will be added to\n    /// the pool, effectively distributing them to the stakers.\n    uint256 public currentApr = (maxApr + minApr) / 2;\n\n    // Snapshot block number of the last vote created at one of the DAO\n    // Api3Voting apps\n    uint256 private lastVoteSnapshotBlock;\n    mapping(uint256 => uint256) private snapshotBlockToTimestamp;\n\n    // We keep checkpoints for two most recent blocks at which totalShares has\n    // been updated. Note that the indices do not indicate chronological\n    // ordering.\n    Checkpoint private totalSharesCheckpoint1;\n    Checkpoint private totalSharesCheckpoint2;\n\n    /// @dev Reverts if the caller is not an API3 DAO Agent\n    modifier onlyAgentApp() {\n        require(\n            msg.sender == agentAppPrimary || msg.sender == agentAppSecondary,\n            ERROR_ONLY_AGENT\n            );\n        _;\n    }\n\n    /// @dev Reverts if the caller is not the primary API3 DAO Agent\n    modifier onlyAgentAppPrimary() {\n        require(msg.sender == agentAppPrimary, ERROR_ONLY_PRIMARY_AGENT);\n        _;\n    }\n\n    /// @dev Reverts if the caller is not an API3 DAO Api3Voting app\n    modifier onlyVotingApp() {\n        require(\n            msg.sender == votingAppPrimary || msg.sender == votingAppSecondary,\n            ERROR_ONLY_VOTING\n            );\n        _;\n    }\n\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n    {\n        api3Token = IApi3Token(api3TokenAddress);\n        // Initialize the share price at 1\n        updateTotalShares(1);\n        totalStake = 1;\n        // Set the current epoch as the genesis epoch and skip its reward\n        // payment\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        genesisEpoch = currentEpoch;\n        epochIndexOfLastRewardPayment = currentEpoch;\n    }\n\n    /// @notice Called after deployment to set the addresses of the DAO apps\n    /// @dev This can also be called later on by the primary Agent to update\n    /// all app addresses as a means of upgrade\n    /// @param _agentAppPrimary Address of the primary Agent\n    /// @param _agentAppSecondary Address of the secondary Agent\n    /// @param _votingAppPrimary Address of the primary Api3Voting\n    /// @param _votingAppSecondary Address of the secondary Api3Voting\n    function setDaoApps(\n        address _agentAppPrimary,\n        address _agentAppSecondary,\n        address _votingAppPrimary,\n        address _votingAppSecondary\n        )\n        external\n        override\n    {\n        require(\n            agentAppPrimary == address(0) || msg.sender == agentAppPrimary,\n            ERROR_ONLY_AGENT\n            );\n        require(\n            _agentAppPrimary != address(0)\n                && _agentAppSecondary  != address(0)\n                && _votingAppPrimary  != address(0)\n                && _votingAppSecondary  != address(0),\n            ERROR_ZERO_ADDRESS\n            );\n        agentAppPrimary = _agentAppPrimary;\n        agentAppSecondary = _agentAppSecondary;\n        votingAppPrimary = _votingAppPrimary;\n        votingAppSecondary = _votingAppSecondary;\n        emit SetDaoApps(\n            agentAppPrimary,\n            agentAppSecondary,\n            votingAppPrimary,\n            votingAppSecondary\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the authorization status of a\n    /// claims manager contract\n    /// @dev The claims manager is a trusted contract that is allowed to\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\n    /// claims.\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @param claimsManager Claims manager contract address\n    /// @param status Authorization status\n    function setClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        )\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        claimsManagerStatus[claimsManager] = status;\n        emit SetClaimsManagerStatus(\n            claimsManager,\n            status\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the stake target\n    /// @param _stakeTarget Stake target\n    function setStakeTarget(uint256 _stakeTarget)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(\n            _stakeTarget <= HUNDRED_PERCENT,\n            ERROR_PERCENTAGE);\n        uint256 oldStakeTarget = stakeTarget;\n        stakeTarget = _stakeTarget;\n        emit SetStakeTarget(\n            oldStakeTarget,\n            stakeTarget\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the maximum APR\n    /// @param _maxApr Maximum APR\n    function setMaxApr(uint256 _maxApr)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(_maxApr >= minApr, ERROR_APR);\n        uint256 oldMaxApr = maxApr;\n        maxApr = _maxApr;\n        emit SetMaxApr(\n            oldMaxApr,\n            maxApr\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the minimum APR\n    /// @param _minApr Minimum APR\n    function setMinApr(uint256 _minApr)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(_minApr <= maxApr, ERROR_APR);\n        uint256 oldMinApr = minApr;\n        minApr = _minApr;\n        emit SetMinApr(\n            oldMinApr,\n            minApr\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the unstake waiting period\n    /// @dev This may want to be increased to provide more time for insurance\n    /// claims to be resolved.\n    /// Even when the insurance functionality is not implemented, the minimum\n    /// valid value is `EPOCH_LENGTH` to prevent users from unstaking,\n    /// withdrawing and staking with another address to work around the\n    /// proposal spam protection.\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @param _unstakeWaitPeriod Unstake waiting period\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        require(_unstakeWaitPeriod >= EPOCH_LENGTH, ERROR_UNSTAKE_PERIOD);\n        uint256 oldUnstakeWaitPeriod = unstakeWaitPeriod;\n        unstakeWaitPeriod = _unstakeWaitPeriod;\n        emit SetUnstakeWaitPeriod(\n            oldUnstakeWaitPeriod,\n            unstakeWaitPeriod\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the APR update steps\n    /// @dev aprUpdateStep can be 0% or 100%+\n    /// @param _aprUpdateStep APR update steps\n    function setAprUpdateStep(uint256 _aprUpdateStep)\n        external\n        override\n        onlyAgentApp()\n    {\n        uint256 oldAprUpdateStep = aprUpdateStep;\n        aprUpdateStep = _aprUpdateStep;\n        emit SetAprUpdateStep(\n            oldAprUpdateStep,\n            aprUpdateStep\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the voting power threshold for\n    /// proposals\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @dev Proposal voting power is limited between 0.1% and 10%. 0.1% is to\n    /// ensure that no more than 1000 proposals can be made within an epoch\n    /// (see `getReceivedDelegationAt()`) and any value above 10% is certainly\n    /// an error.\n    /// @param _proposalVotingPowerThreshold Voting power threshold for\n    /// proposals\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        require(\n            _proposalVotingPowerThreshold >= ONE_PERCENT / 10\n                && _proposalVotingPowerThreshold <= 10 * ONE_PERCENT,\n            ERROR_PROPOSAL_THRESHOLD);\n        uint256 oldProposalVotingPowerThreshold = proposalVotingPowerThreshold;\n        proposalVotingPowerThreshold = _proposalVotingPowerThreshold;\n        emit SetProposalVotingPowerThreshold(\n            oldProposalVotingPowerThreshold,\n            proposalVotingPowerThreshold\n            );\n    }\n\n    /// @notice Called by a DAO Api3Voting app to update the last vote snapshot\n    /// block number\n    /// @param snapshotBlock Last vote snapshot block number\n    function updateLastVoteSnapshotBlock(uint256 snapshotBlock)\n        external\n        override\n        onlyVotingApp()\n    {\n        lastVoteSnapshotBlock = snapshotBlock;\n        snapshotBlockToTimestamp[snapshotBlock] = block.timestamp;\n        emit UpdatedLastVoteSnapshotBlock(\n            msg.sender,\n            snapshotBlock,\n            block.timestamp\n            );\n    }\n\n    /// @notice Called by a DAO Api3Voting app at proposal creation-time to\n    /// update the timestamp of the user's most recent proposal\n    /// @param userAddress User address\n    function updateMostRecentProposalTimestamp(address userAddress)\n        external\n        override\n        onlyVotingApp()\n    {\n        users[userAddress].mostRecentProposalTimestamp = block.timestamp;\n    }\n\n    /// @notice Called by a DAO Api3Voting app at voting-time to update the\n    /// timestamp of the user's most recent vote\n    /// @param userAddress User address\n    function updateMostRecentVoteTimestamp(address userAddress)\n        external\n        override\n        onlyVotingApp()\n    {\n        users[userAddress].mostRecentVoteTimestamp = block.timestamp;\n    }\n\n    /// @notice Called internally to update the total shares history\n    /// @dev `fromBlock0` and `fromBlock1` will be two different block numbers\n    /// when totalShares history was last updated. If one of these\n    /// `fromBlock`s match with `block.number`, we simply update the value\n    /// (because the history keeps the most recent value from that block). If\n    /// not, we can overwrite the older one, as we no longer need it.\n    /// @param newTotalShares Total shares value to insert into history\n    function updateTotalShares(uint256 newTotalShares)\n        internal\n    {\n        if (block.number == totalSharesCheckpoint1.fromBlock)\n        {\n            totalSharesCheckpoint1.value = newTotalShares;\n        }\n        else if (block.number == totalSharesCheckpoint2.fromBlock)\n        {\n            totalSharesCheckpoint2.value = newTotalShares;\n        }\n        else {\n            if (totalSharesCheckpoint1.fromBlock < totalSharesCheckpoint2.fromBlock)\n            {\n                totalSharesCheckpoint1.fromBlock = block.number;\n                totalSharesCheckpoint1.value = newTotalShares;\n            }\n            else\n            {\n                totalSharesCheckpoint2.fromBlock = block.number;\n                totalSharesCheckpoint2.value = newTotalShares;\n            }\n        }\n    }\n\n    /// @notice Called internally to get the current total shares\n    /// @return Current total shares\n    function totalShares()\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalSharesCheckpoint1.fromBlock < totalSharesCheckpoint2.fromBlock)\n        {\n            return totalSharesCheckpoint2.value;\n        }\n        else\n        {\n            return totalSharesCheckpoint1.value;\n        }\n    }\n\n    /// @notice Called internally to get the total shares one block ago\n    /// @return Total shares one block ago\n    function totalSharesOneBlockAgo()\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalSharesCheckpoint2.fromBlock == block.number)\n        {\n            return totalSharesCheckpoint1.value;\n        }\n        else if (totalSharesCheckpoint1.fromBlock == block.number)\n        {\n            return totalSharesCheckpoint2.value;\n        }\n        else\n        {\n            return totalShares();\n        }\n    }\n\n    /// @notice Called internally to update a checkpoint array\n    /// @param checkpointArray Checkpoint array to be updated\n    /// @param value Value to be updated with\n    function updateCheckpointArray(\n        Checkpoint[] storage checkpointArray,\n        uint256 value\n        )\n        internal\n    {\n        if (checkpointArray.length == 0)\n        {\n            checkpointArray.push(Checkpoint({\n                fromBlock: lastVoteSnapshotBlock,\n                value: value\n                }));\n        }\n        else\n        {\n            Checkpoint storage lastElement = checkpointArray[checkpointArray.length - 1];\n            if (lastElement.fromBlock < lastVoteSnapshotBlock)\n            {\n                checkpointArray.push(Checkpoint({\n                    fromBlock: lastVoteSnapshotBlock,\n                    value: value\n                    }));\n            }\n            else\n            {\n                lastElement.value = value;\n            }\n        }\n    }\n\n    /// @notice Called internally to update an address checkpoint array\n    /// @param addressCheckpointArray Address checkpoint array to be updated\n    /// @param _address Address to be updated with\n    function updateAddressCheckpointArray(\n        AddressCheckpoint[] storage addressCheckpointArray,\n        address _address\n        )\n        internal\n    {\n        if (addressCheckpointArray.length == 0)\n        {\n            addressCheckpointArray.push(AddressCheckpoint({\n                fromBlock: lastVoteSnapshotBlock,\n                _address: _address\n                }));\n        }\n        else\n        {\n            AddressCheckpoint storage lastElement = addressCheckpointArray[addressCheckpointArray.length - 1];\n            if (lastElement.fromBlock < lastVoteSnapshotBlock)\n            {\n                addressCheckpointArray.push(AddressCheckpoint({\n                    fromBlock: lastVoteSnapshotBlock,\n                    _address: _address\n                    }));\n            }\n            else\n            {\n                lastElement._address = _address;\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IGetterUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IStateUtils.sol\";\n\ninterface IGetterUtils is IStateUtils {\n    function balanceOfAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function balanceOf(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function totalSupplyOneBlockAgo()\n        external\n        view\n        returns(uint256);\n\n    function totalSupply()\n        external\n        view\n        returns(uint256);\n\n    function userSharesAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userShares(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function userSharesAtWithBinarySearch(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userStake(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function getReceivedDelegationAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userReceivedDelegation(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function getUserDelegateAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(address);\n\n    function getUserDelegate(address userAddress)\n        external\n        view\n        returns(address);\n\n    function getUserLocked(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function getUser(address userAddress)\n        external\n        view\n        returns(\n            uint256 unstaked,\n            uint256 vesting,\n            uint256 unstakeShares,\n            uint256 unstakeAmount,\n            uint256 unstakeScheduledFor,\n            uint256 mostRecentProposalTimestamp,\n            uint256 mostRecentVoteTimestamp,\n            uint256 mostRecentDelegationTimestamp,\n            uint256 mostRecentUndelegationTimestamp\n            );\n}\n"
    },
    "contracts/pool-contracts-symlink/auxiliary/interfaces/v0.8.4/IApi3Token.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"./IERC20.sol\";\n\ninterface IApi3Token is IERC20 {\n    event MinterStatusUpdated(\n        address indexed minterAddress,\n        bool minterStatus\n        );\n\n    event BurnerStatusUpdated(\n        address indexed burnerAddress,\n        bool burnerStatus\n        );\n\n    function updateMinterStatus(\n        address minterAddress,\n        bool minterStatus\n        )\n        external;\n\n    function updateBurnerStatus(bool burnerStatus)\n        external;\n\n    function mint(\n        address account,\n        uint256 amount\n        )\n        external;\n\n    function burn(uint256 amount)\n        external;\n\n    function getMinterStatus(address minterAddress)\n        external\n        view\n        returns(bool minterStatus);\n\n    function getBurnerStatus(address burnerAddress)\n        external\n        view\n        returns(bool burnerStatus);\n}\n"
    },
    "contracts/pool-contracts-symlink/interfaces/IStateUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IStateUtils {\n    event SetDaoApps(\n        address agentAppPrimary,\n        address agentAppSecondary,\n        address votingAppPrimary,\n        address votingAppSecondary\n        );\n\n    event SetClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        );\n\n    event SetStakeTarget(\n        uint256 oldTarget,\n        uint256 newTarget\n        );\n\n    event SetMaxApr(\n        uint256 oldMaxApr,\n        uint256 maxApr\n        );\n\n    event SetMinApr(\n        uint256 oldMinApr,\n        uint256 minApr\n        );\n\n    event SetUnstakeWaitPeriod(\n        uint256 oldUnstakeWaitPeriod,\n        uint256 unstakeWaitPeriod\n        );\n\n    event SetAprUpdateStep(\n        uint256 oldAprUpdateStep,\n        uint256 aprUpdateStep\n        );\n\n    event SetProposalVotingPowerThreshold(\n        uint256 oldProposalVotingPowerThreshold,\n        uint256 proposalVotingPowerThreshold\n        );\n\n    event PublishedSpecsUrl(\n        address indexed votingApp,\n        uint256 indexed proposalIndex,\n        address userAddress,\n        string specsUrl\n        );\n\n    event UpdatedLastVoteSnapshotBlock(\n        address votingApp,\n        uint256 lastVoteSnapshotBlock,\n        uint256 lastVoteSnapshotBlockUpdateTimestamp\n        );\n\n    function setDaoApps(\n        address _agentAppPrimary,\n        address _agentAppSecondary,\n        address _votingAppPrimary,\n        address _votingAppSecondary\n        )\n        external;\n\n    function setClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        )\n        external;\n\n    function setStakeTarget(uint256 _stakeTarget)\n        external;\n\n    function setMaxApr(uint256 _maxApr)\n        external;\n\n    function setMinApr(uint256 _minApr)\n        external;\n\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n        external;\n\n    function setAprUpdateStep(uint256 _aprUpdateStep)\n        external;\n\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n        external;\n\n    function updateLastVoteSnapshotBlock(uint256 snapshotBlock)\n        external;\n\n    function updateMostRecentProposalTimestamp(address userAddress)\n        external;\n\n    function updateMostRecentVoteTimestamp(address userAddress)\n        external;\n}\n"
    },
    "contracts/pool-contracts-symlink/auxiliary/interfaces/v0.8.4/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
